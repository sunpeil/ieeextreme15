
import numpy as np
import random

def pool(plant,a,b,R,C):
    p = np.zeros([R,C])
    x,y = len(plant), len(plant[0])
    p[a:a+x, b:b+y] = plant
    return p


def exit_plant_t(a,b,X,Y,R,C):
    exit_plant = np.ones([R,C])
    exit_plant[a:a+X,b:b+Y] = -1
    return exit_plant



if __name__ == '__main__':
    R, C= [int(i) for i in input().split(' ')]
    X, Y = [int(i) for i in input().split(' ')]
    a = []
    for i in range(R):
        L = [int(i) for i in input().split(' ')]
        a.append(L)
    A = np.array(a)
    exit_plant = np.ones([R,C])
    plant1 = np.ones([X,Y])
    plant2 = np.ones([Y,X])
    max_get1 = 0
    max_get2 = 0
    max_get = 0
    i = 100
    temp = 0
    while(i>0):
        i -= 1
        ii,jj = random.randint(0,C-X),random.randint(0,R-Y)
        p = pool(plant1, ii, jj, R, C)
        max_get1 = np.sum(p * exit_plant * A)
        exit_plant_1 = exit_plant_t(ii,jj,X,Y,R,C)

        for i in range(C - X + 1):
            for j in range(R - Y + 1):
                p = pool(plant1, i, j, R, C)
                curr_get = np.sum(p*exit_plant_1*A)
                if curr_get > max_get2:
                    max_get2 = curr_get
                    c_max = i
                    d_max = j
        for i in range(C - Y + 1):
            for j in range(R - X + 1):
                p = pool(plant2, i, j, R, C)
                curr_get = np.sum(p*exit_plant_1*A)
                if curr_get > max_get2:
                    max_get2 = curr_get
                    c_max = i
                    d_max = j
        curr_max = max_get
        max_get = max(max_get1+max_get2,max_get)
        if curr_max == max_get:
            temp += 1
        if temp > 5:
            break
    print(int(max_get))
